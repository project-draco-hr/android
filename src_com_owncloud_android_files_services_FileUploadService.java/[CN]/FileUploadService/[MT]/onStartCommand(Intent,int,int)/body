{
  AbstractList<UploadDbObject> requestedUploads=new Vector<UploadDbObject>();
  if (intent == null) {
    List<UploadDbObject> list=mDb.getAllStoredUploads();
    requestedUploads.addAll(list);
  }
 else {
    UploadSingleMulti uploadType=(UploadSingleMulti)intent.getSerializableExtra(KEY_UPLOAD_TYPE);
    if (uploadType == null) {
      Log_OC.e(TAG,"Incorrect or no upload type provided");
      return Service.START_NOT_STICKY;
    }
    Account account=intent.getParcelableExtra(KEY_ACCOUNT);
    if (!AccountUtils.exists(account,getApplicationContext())) {
      Log_OC.e(TAG,"KEY_ACCOUNT no set or provided KEY_ACCOUNT does not exist");
      return Service.START_NOT_STICKY;
    }
    OCFile[] files=null;
    if (intent.hasExtra(KEY_FILE)) {
      if (uploadType == UploadSingleMulti.UPLOAD_SINGLE_FILE) {
        files=new OCFile[]{intent.getParcelableExtra(KEY_FILE)};
      }
 else {
        files=(OCFile[])intent.getParcelableArrayExtra(KEY_FILE);
      }
    }
 else {
      if (!intent.hasExtra(KEY_LOCAL_FILE) || !intent.hasExtra(KEY_REMOTE_FILE)) {
        Log_OC.e(TAG,"Not enough information provided in intent");
        return Service.START_NOT_STICKY;
      }
      String[] localPaths;
      String[] remotePaths;
      String[] mimeTypes;
      if (uploadType == UploadSingleMulti.UPLOAD_SINGLE_FILE) {
        localPaths=new String[]{intent.getStringExtra(KEY_LOCAL_FILE)};
        remotePaths=new String[]{intent.getStringExtra(KEY_REMOTE_FILE)};
        mimeTypes=new String[]{intent.getStringExtra(KEY_MIME_TYPE)};
      }
 else {
        localPaths=intent.getStringArrayExtra(KEY_LOCAL_FILE);
        remotePaths=intent.getStringArrayExtra(KEY_REMOTE_FILE);
        mimeTypes=intent.getStringArrayExtra(KEY_MIME_TYPE);
      }
      if (localPaths.length != remotePaths.length) {
        Log_OC.e(TAG,"Different number of remote paths and local paths!");
        return Service.START_NOT_STICKY;
      }
      files=new OCFile[localPaths.length];
      for (int i=0; i < localPaths.length; i++) {
        files[i]=obtainNewOCFileToUpload(remotePaths[i],localPaths[i],((mimeTypes != null) ? mimeTypes[i] : (String)null));
        if (files[i] == null) {
          Log_OC.e(TAG,"obtainNewOCFileToUpload() returned null for remotePaths[i]:" + remotePaths[i] + " and localPaths[i]:"+ localPaths[i]);
          return Service.START_NOT_STICKY;
        }
      }
    }
    boolean forceOverwrite=intent.getBooleanExtra(KEY_FORCE_OVERWRITE,false);
    boolean isCreateRemoteFolder=intent.getBooleanExtra(KEY_CREATE_REMOTE_FOLDER,false);
    boolean isUseWifiOnly=intent.getBooleanExtra(KEY_WIFI_ONLY,true);
    LocalBehaviour localAction=(LocalBehaviour)intent.getSerializableExtra(KEY_LOCAL_BEHAVIOUR);
    if (localAction == null)     localAction=LocalBehaviour.LOCAL_BEHAVIOUR_COPY;
    for (int i=0; i < files.length; i++) {
      UploadDbObject uploadObject=new UploadDbObject();
      uploadObject.setRemotePath(files[i].getRemotePath());
      uploadObject.setLocalPath(files[i].getStoragePath());
      uploadObject.setMimeType(files[i].getMimetype());
      uploadObject.setAccountName(account.name);
      uploadObject.setForceOverwrite(forceOverwrite);
      uploadObject.setCreateRemoteFolder(isCreateRemoteFolder);
      uploadObject.setLocalAction(localAction);
      uploadObject.setUseWifiOnly(isUseWifiOnly);
      uploadObject.setUploadStatus(UploadStatus.UPLOAD_LATER);
      mDb.storeUpload(uploadObject,"upload at " + new Date());
      requestedUploads.add(uploadObject);
    }
  }
  if (requestedUploads.size() > 0) {
    Message msg=mServiceHandler.obtainMessage();
    msg.arg1=startId;
    msg.obj=requestedUploads;
    mServiceHandler.sendMessage(msg);
  }
  Log_OC.i(TAG,"mPendingUploads size:" + mActiveUploads.size());
  return Service.START_NOT_STICKY;
}
