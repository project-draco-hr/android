{
  Log_OC.i(TAG,"onHandleIntent start");
  Log_OC.i(TAG,"mPendingUploads size:" + mPendingUploads.size() + " - before adding new uploads.");
  if (intent == null || intent.hasExtra(KEY_RETRY)) {
    Log_OC.d(TAG,"Receive null intent.");
    int countAddedEntries=0;
    UploadDbObject[] list=mDb.getPendingUploads();
    for (    UploadDbObject uploadDbObject : list) {
      String uploadKey=buildRemoteName(uploadDbObject);
      UploadDbObject previous=mPendingUploads.putIfAbsent(uploadKey,uploadDbObject);
      if (previous == null) {
        uploadDbObject.setUploadStatus(UploadStatus.UPLOAD_LATER);
        mDb.updateUpload(uploadDbObject);
        countAddedEntries++;
      }
 else {
      }
    }
    Log_OC.d(TAG,"added " + countAddedEntries + " entrie(s) to mPendingUploads (this should be 0 except for the first time).");
  }
 else {
    Log_OC.d(TAG,"Receive upload intent.");
    UploadSingleMulti uploadType=(UploadSingleMulti)intent.getSerializableExtra(KEY_UPLOAD_TYPE);
    if (uploadType == null) {
      Log_OC.e(TAG,"Incorrect or no upload type provided");
      return;
    }
    Account account=intent.getParcelableExtra(KEY_ACCOUNT);
    if (!AccountUtils.exists(account,getApplicationContext())) {
      Log_OC.e(TAG,"KEY_ACCOUNT no set or provided KEY_ACCOUNT does not exist");
      return;
    }
    OCFile[] files=null;
    if (intent.hasExtra(KEY_FILE)) {
      if (uploadType == UploadSingleMulti.UPLOAD_SINGLE_FILE) {
        files=new OCFile[]{intent.getParcelableExtra(KEY_FILE)};
      }
 else {
        files=(OCFile[])intent.getParcelableArrayExtra(KEY_FILE);
      }
    }
 else {
      if (!intent.hasExtra(KEY_LOCAL_FILE) || !intent.hasExtra(KEY_REMOTE_FILE)) {
        Log_OC.e(TAG,"Not enough information provided in intent");
        return;
      }
      String[] localPaths;
      String[] remotePaths;
      String[] mimeTypes;
      if (uploadType == UploadSingleMulti.UPLOAD_SINGLE_FILE) {
        localPaths=new String[]{intent.getStringExtra(KEY_LOCAL_FILE)};
        remotePaths=new String[]{intent.getStringExtra(KEY_REMOTE_FILE)};
        mimeTypes=new String[]{intent.getStringExtra(KEY_MIME_TYPE)};
      }
 else {
        localPaths=intent.getStringArrayExtra(KEY_LOCAL_FILE);
        remotePaths=intent.getStringArrayExtra(KEY_REMOTE_FILE);
        mimeTypes=intent.getStringArrayExtra(KEY_MIME_TYPE);
      }
      if (localPaths.length != remotePaths.length) {
        Log_OC.e(TAG,"Different number of remote paths and local paths!");
        return;
      }
      files=new OCFile[localPaths.length];
      for (int i=0; i < localPaths.length; i++) {
        files[i]=obtainNewOCFileToUpload(remotePaths[i],localPaths[i],((mimeTypes != null) ? mimeTypes[i] : (String)null));
        if (files[i] == null) {
          Log_OC.e(TAG,"obtainNewOCFileToUpload() returned null for remotePaths[i]:" + remotePaths[i] + " and localPaths[i]:"+ localPaths[i]);
          return;
        }
      }
    }
    boolean forceOverwrite=intent.getBooleanExtra(KEY_FORCE_OVERWRITE,false);
    boolean isCreateRemoteFolder=intent.getBooleanExtra(KEY_CREATE_REMOTE_FOLDER,false);
    boolean isUseWifiOnly=intent.getBooleanExtra(KEY_WIFI_ONLY,true);
    boolean isWhileChargingOnly=intent.getBooleanExtra(KEY_WHILE_CHARGING_ONLY,true);
    long uploadTimestamp=intent.getLongExtra(KEY_UPLOAD_TIMESTAMP,-1);
    LocalBehaviour localAction=(LocalBehaviour)intent.getSerializableExtra(KEY_LOCAL_BEHAVIOUR);
    if (localAction == null)     localAction=LocalBehaviour.LOCAL_BEHAVIOUR_COPY;
    for (int i=0; i < files.length; i++) {
      UploadDbObject uploadObject=new UploadDbObject(files[i]);
      uploadObject.setAccountName(account.name);
      uploadObject.setForceOverwrite(forceOverwrite);
      uploadObject.setCreateRemoteFolder(isCreateRemoteFolder);
      uploadObject.setLocalAction(localAction);
      uploadObject.setUseWifiOnly(isUseWifiOnly);
      uploadObject.setWhileChargingOnly(isWhileChargingOnly);
      uploadObject.setUploadTimestamp(uploadTimestamp);
      uploadObject.setUploadStatus(UploadStatus.UPLOAD_LATER);
      String uploadKey=buildRemoteName(uploadObject);
      UploadDbObject previous=mPendingUploads.putIfAbsent(uploadKey,uploadObject);
      if (previous == null) {
        boolean success=mDb.storeUpload(uploadObject);
        if (!success) {
          Log_OC.e(TAG,"Could not add upload to database. It might be a duplicate. Ignore.");
        }
      }
 else {
        Log_OC.w(TAG,"FileUploadService got upload intent for file which is already queued: " + uploadObject.getRemotePath());
      }
    }
  }
  Log_OC.i(TAG,"mPendingUploads size:" + mPendingUploads.size() + " - before uploading.");
  Iterator<String> it=mPendingUploads.keySet().iterator();
  while (it.hasNext()) {
    String upload=it.next();
    UploadDbObject uploadDbObject=mPendingUploads.get(upload);
switch (canUploadFileNow(uploadDbObject)) {
case NOW:
      Log_OC.d(TAG,"Calling uploadFile for " + upload);
    RemoteOperationResult uploadResult=uploadFile(uploadDbObject);
  updateDataseUploadResult(uploadResult,mCurrentUpload);
notifyUploadResult(uploadResult,mCurrentUpload);
sendFinalBroadcast(uploadResult,mCurrentUpload);
if (!shouldRetryFailedUpload(uploadResult)) {
Log_OC.d(TAG,"Upload with result " + uploadResult.getCode() + ": "+ uploadResult.getLogMessage()+ " will be abandoned.");
mPendingUploads.remove(buildRemoteName(uploadDbObject));
}
mCurrentUpload=null;
break;
case LATER:
break;
case FILE_GONE:
mDb.updateUpload(uploadDbObject.getLocalPath(),UploadStatus.UPLOAD_FAILED_GIVE_UP,new RemoteOperationResult(ResultCode.FILE_NOT_FOUND));
it.remove();
break;
case ERROR:
Log_OC.e(TAG,"canUploadFileNow() returned ERROR. Fix that!");
break;
}
}
Log_OC.i(TAG,"mPendingUploads size:" + mPendingUploads.size() + " - after uploading.");
Log_OC.i(TAG,"onHandleIntent end");
}
