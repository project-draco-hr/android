{
  Log_OC.d(TAG,"onHandleIntent start");
  Log_OC.d(TAG,"mPendingUploads size:" + mPendingUploads.size() + " - before adding new uploads.");
  if (intent == null || intent.hasExtra(KEY_RETRY)) {
    Log_OC.d(TAG,"Received null intent.");
    int countAddedEntries=0;
    UploadDbObject[] list=mDb.getPendingUploads();
    for (    UploadDbObject uploadDbObject : list) {
      Log_OC.d(TAG,"Retrieved from DB: " + uploadDbObject.toFormattedString());
      String uploadKey=buildRemoteName(uploadDbObject);
      UploadDbObject previous=mPendingUploads.putIfAbsent(uploadKey,uploadDbObject);
      if (previous == null) {
        Log_OC.d(TAG,"mPendingUploads added: " + uploadDbObject.toFormattedString());
        countAddedEntries++;
      }
 else {
      }
    }
    Log_OC.d(TAG,"added " + countAddedEntries + " entrie(s) to mPendingUploads (this should be 0 except for the first time).");
    mDb.notifyObserversNow();
  }
 else {
    Log_OC.d(TAG,"Receive upload intent.");
    UploadQuantity uploadType=(UploadQuantity)intent.getSerializableExtra(KEY_UPLOAD_TYPE);
    if (uploadType == null) {
      Log_OC.e(TAG,"Incorrect or no upload type provided");
      return;
    }
    Account account=intent.getParcelableExtra(KEY_ACCOUNT);
    if (!AccountUtils.exists(account,getApplicationContext())) {
      Log_OC.e(TAG,"KEY_ACCOUNT no set or provided KEY_ACCOUNT does not exist");
      return;
    }
    OCFile[] files=null;
    if (intent.hasExtra(KEY_FILE)) {
      if (uploadType == UploadQuantity.UPLOAD_SINGLE_FILE) {
        files=new OCFile[]{intent.getParcelableExtra(KEY_FILE)};
      }
 else {
        files=(OCFile[])intent.getParcelableArrayExtra(KEY_FILE);
      }
    }
 else {
      if (!intent.hasExtra(KEY_LOCAL_FILE) || !intent.hasExtra(KEY_REMOTE_FILE)) {
        Log_OC.e(TAG,"Not enough information provided in intent");
        return;
      }
      String[] localPaths;
      String[] remotePaths;
      String[] mimeTypes;
      if (uploadType == UploadQuantity.UPLOAD_SINGLE_FILE) {
        localPaths=new String[]{intent.getStringExtra(KEY_LOCAL_FILE)};
        remotePaths=new String[]{intent.getStringExtra(KEY_REMOTE_FILE)};
        mimeTypes=new String[]{intent.getStringExtra(KEY_MIME_TYPE)};
      }
 else {
        localPaths=intent.getStringArrayExtra(KEY_LOCAL_FILE);
        remotePaths=intent.getStringArrayExtra(KEY_REMOTE_FILE);
        mimeTypes=intent.getStringArrayExtra(KEY_MIME_TYPE);
      }
      if (localPaths.length != remotePaths.length) {
        Log_OC.e(TAG,"Different number of remote paths and local paths!");
        return;
      }
      files=new OCFile[localPaths.length];
      for (int i=0; i < localPaths.length; i++) {
        files[i]=obtainNewOCFileToUpload(remotePaths[i],localPaths[i],((mimeTypes != null) ? mimeTypes[i] : (String)null));
        if (files[i] == null) {
          Log_OC.e(TAG,"obtainNewOCFileToUpload() returned null for remotePaths[i]:" + remotePaths[i] + " and localPaths[i]:"+ localPaths[i]);
          return;
        }
      }
    }
    boolean forceOverwrite=intent.getBooleanExtra(KEY_FORCE_OVERWRITE,false);
    boolean isCreateRemoteFolder=intent.getBooleanExtra(KEY_CREATE_REMOTE_FOLDER,false);
    boolean isUseWifiOnly=intent.getBooleanExtra(KEY_WIFI_ONLY,true);
    boolean isWhileChargingOnly=intent.getBooleanExtra(KEY_WHILE_CHARGING_ONLY,false);
    long uploadTimestamp=intent.getLongExtra(KEY_UPLOAD_TIMESTAMP,-1);
    LocalBehaviour localAction=(LocalBehaviour)intent.getSerializableExtra(KEY_LOCAL_BEHAVIOUR);
    if (localAction == null)     localAction=LocalBehaviour.LOCAL_BEHAVIOUR_COPY;
    for (int i=0; i < files.length; i++) {
      UploadDbObject uploadObject=new UploadDbObject(files[i]);
      uploadObject.setAccountName(account.name);
      uploadObject.setForceOverwrite(forceOverwrite);
      uploadObject.setCreateRemoteFolder(isCreateRemoteFolder);
      uploadObject.setLocalAction(localAction);
      uploadObject.setUseWifiOnly(isUseWifiOnly);
      uploadObject.setWhileChargingOnly(isWhileChargingOnly);
      uploadObject.setUploadTimestamp(uploadTimestamp);
      uploadObject.setUploadStatus(UploadStatus.UPLOAD_LATER);
      String uploadKey=buildRemoteName(uploadObject);
      UploadDbObject previous=mPendingUploads.putIfAbsent(uploadKey,uploadObject);
      if (previous == null) {
        Log_OC.d(TAG,"mPendingUploads added: " + uploadObject.toFormattedString());
        if (mDb.removeUpload(uploadObject.getLocalPath()) > 0) {
          Log_OC.w(TAG,"There was an old DB entry " + uploadObject.getLocalPath() + " which had to be removed in order to add new one.");
        }
        boolean success=mDb.storeUpload(uploadObject);
        if (!success) {
          Log_OC.e(TAG,"Could not add upload " + uploadObject.getLocalPath() + " to database. This should not happen.");
        }
      }
 else {
        Log_OC.w(TAG,"FileUploadService got upload intent for file which is already queued: " + uploadObject.getRemotePath());
      }
    }
  }
  Iterator<String> it;
  if (intent != null && intent.getStringExtra(KEY_RETRY_REMOTE_PATH) != null) {
    ArrayList<String> list=new ArrayList<String>(1);
    String remotePath=intent.getStringExtra(KEY_RETRY_REMOTE_PATH);
    list.add(remotePath);
    it=list.iterator();
    UploadDbObject uploadDbObject=mPendingUploads.get(remotePath);
    uploadDbObject.setUploadStatus(UploadStatus.UPLOAD_LATER);
    uploadDbObject.setLastResult(null);
    mDb.updateUploadStatus(uploadDbObject);
    Log_OC.d(TAG,"Start uploading " + remotePath);
  }
 else {
    it=mPendingUploads.keySet().iterator();
  }
  if (it.hasNext()) {
    while (it.hasNext()) {
      String upload=it.next();
      UploadDbObject uploadDbObject=mPendingUploads.get(upload);
      if (uploadDbObject == null) {
        Log_OC.e(TAG,"Cannot upload null. Fix that!");
        continue;
      }
      UploadTask uploadTask=new UploadTask(uploadDbObject);
      uploadExecutor.submit(uploadTask);
    }
    StopSelfTask stopSelfTask=new StopSelfTask(intentStartId);
    uploadExecutor.submit(stopSelfTask);
  }
 else {
    stopSelf(intentStartId);
  }
  Log_OC.d(TAG,"onHandleIntent end");
}
