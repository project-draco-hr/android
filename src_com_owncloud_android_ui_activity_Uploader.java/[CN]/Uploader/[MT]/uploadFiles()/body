{
  try {
    ArrayList<String> local=new ArrayList<String>();
    ArrayList<String> remote=new ArrayList<String>();
    for (    Parcelable mStream : mStreamsToUpload) {
      Uri uri=(Uri)mStream;
      String data=null;
      String filePath="";
      if (uri != null) {
        if (uri.getScheme().equals("content")) {
          String mimeType=getContentResolver().getType(uri);
          if (mimeType.contains("image")) {
            String[] CONTENT_PROJECTION={Images.Media.DATA,Images.Media.DISPLAY_NAME,Images.Media.MIME_TYPE,Images.Media.SIZE};
            Cursor c=getContentResolver().query(uri,CONTENT_PROJECTION,null,null,null);
            c.moveToFirst();
            int index=c.getColumnIndex(Images.Media.DATA);
            data=c.getString(index);
            filePath=mUploadPath + c.getString(c.getColumnIndex(Images.Media.DISPLAY_NAME));
          }
 else           if (mimeType.contains("video")) {
            String[] CONTENT_PROJECTION={Video.Media.DATA,Video.Media.DISPLAY_NAME,Video.Media.MIME_TYPE,Video.Media.SIZE,Video.Media.DATE_MODIFIED};
            Cursor c=getContentResolver().query(uri,CONTENT_PROJECTION,null,null,null);
            c.moveToFirst();
            int index=c.getColumnIndex(Video.Media.DATA);
            data=c.getString(index);
            filePath=mUploadPath + c.getString(c.getColumnIndex(Video.Media.DISPLAY_NAME));
          }
 else           if (mimeType.contains("audio")) {
            String[] CONTENT_PROJECTION={Audio.Media.DATA,Audio.Media.DISPLAY_NAME,Audio.Media.MIME_TYPE,Audio.Media.SIZE};
            Cursor c=getContentResolver().query(uri,CONTENT_PROJECTION,null,null,null);
            c.moveToFirst();
            int index=c.getColumnIndex(Audio.Media.DATA);
            data=c.getString(index);
            filePath=mUploadPath + c.getString(c.getColumnIndex(Audio.Media.DISPLAY_NAME));
          }
 else {
            Cursor cursor=getContentResolver().query(uri,new String[]{MediaStore.MediaColumns.DISPLAY_NAME},null,null,null);
            cursor.moveToFirst();
            int nameIndex=cursor.getColumnIndex(cursor.getColumnNames()[0]);
            if (nameIndex >= 0) {
              filePath=mUploadPath + cursor.getString(nameIndex);
            }
          }
        }
 else         if (uri.getScheme().equals("file")) {
          filePath=Uri.decode(uri.toString()).replace(uri.getScheme() + "://","");
          if (filePath.contains("mnt")) {
            String splitedFilePath[]=filePath.split("/mnt");
            filePath=splitedFilePath[1];
          }
          final File file=new File(filePath);
          data=file.getAbsolutePath();
          filePath=mUploadPath + file.getName();
        }
 else {
          throw new SecurityException();
        }
        if (data == null) {
          mRemoteCacheData.add(filePath);
          CopyTmpFileAsyncTask copyTask=new CopyTmpFileAsyncTask(this);
          Object[] params={uri,filePath,mRemoteCacheData.size() - 1,getAccount().name,getContentResolver()};
          mNumCacheFile++;
          showWaitingCopyDialog();
          copyTask.execute(params);
        }
 else {
          remote.add(filePath);
          local.add(data);
        }
      }
 else {
        throw new SecurityException();
      }
      Intent intent=new Intent(getApplicationContext(),FileUploadService.class);
      intent.putExtra(FileUploadService.KEY_UPLOAD_TYPE,FileUploadService.UPLOAD_MULTIPLE_FILES);
      intent.putExtra(FileUploadService.KEY_LOCAL_FILE,local.toArray(new String[local.size()]));
      intent.putExtra(FileUploadService.KEY_REMOTE_FILE,remote.toArray(new String[remote.size()]));
      intent.putExtra(FileUploadService.KEY_ACCOUNT,getAccount());
      startService(intent);
      SharedPreferences.Editor appPrefs=PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).edit();
      appPrefs.putString("last_upload_path",mUploadPath);
      appPrefs.apply();
      finish();
    }
  }
 catch (  SecurityException e) {
    String message=String.format(getString(R.string.uploader_error_forbidden_content),getString(R.string.app_name));
    Toast.makeText(this,message,Toast.LENGTH_LONG).show();
  }
}
